Dynamic VLIW
	Allows a dynamic number of instructions to be queued for simultaneous execution

	All inputs within the same queue will be calculated before outputs
		`mov R0, R1` and `mov R1, R0` put into the same queue will result in swapping R0 and R1

	If any exception occurs during the execution of the queued instructions, all output will be discarded

	If multiple exceptions would have theoretically occurred, which one is triggered is undefined

	If outputs from multiple instructions overlap:
		Flag saving will always take priority
		Conditional instructions will be preferred above all other instructions
		Indirect writes, such as `jmp` and `push`, will be preferred over direct writes

		If a conflict still remains, which value will be written to the overlapping area is undefined

		If an exception would be generated by attempting to write one value there but not the other, the exception might not occur if the other value is what is written

	Format:
		size_of_instructions // size so it won't have to parse each to find where the immediate references start
		for each:
			opcode
			size_of_params // size for similar reason as to the above
			if size_of_params == 0:
				num_instructions
			for each param:
				value (see ./parameter.txt for details)

		has_shared_immediate_references
		if has_shared_immediate_references:
			size_of_immediate_references
			for each:
				value

		has_flag_save_definitions
		if has_flag_save_definitions:
			num_flag_save_definitions
			for each:
				instruction index in queue
				which flags to save (1 bit per flag type available)
				where to save them
				bitwise offset in the destination (log2(bits_for_current_mode) bits)

	A minimum of <n> instructions per queue must be accepted by all CPUs
		TODO: define n
		Specific implementations may accept more, up to the maximum specifiable by the format
