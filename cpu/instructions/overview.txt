Dynamic VLIW
	Allows a dynamic number of instructions to be queued for simultaneous execution

	All inputs within the same queue will be calculated before outputs
		`mov R0, R1` and `mov R1, R0` put into the same queue will result in swapping R0 and R1

	If any exception occurs during the execution of the queued instructions, all output will be discarded

	If multiple exceptions would have theoretically occurred, which one is triggered is undefined

	If outputs from multiple instructions overlap:
		Flag saving will always take priority
		Conditional instructions will be preferred above all other instructions
		Indirect writes, such as `jmp` and `push`, will be preferred over direct writes

		If a conflict still remains, which value will be written to the overlapping area is undefined

		If an exception would be generated by attempting to write one value there but not the other, the exception might not occur if the other value is what is written

	Format:
		size_of_instructions
		for each:
			opcode
			num_instructions
			for each * params per instruction:
				value
		size_of_immediate_references
		for each:
			value
		num_flag_save_definitions
		for each:
			instruction index in queue
			which flags to save (1 bit per flag type available)
			where to save them
			bitwise offset in the destination (log2(bits_for_current_mode) bits)

	A minimum of <n> instructions per queue must be accepted by all CPUs
		TODO: define n
		Specific implementations may accept more, up to the maximum specifiable by the format
