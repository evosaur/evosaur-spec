Dynamic VLIW
	Allows a dynamic number of instructions to be queued for simultaneous execution

	All inputs within the same queue will be calculated before outputs
		`mov R0, R1` and `mov R1, R0` put into the same queue will result in swapping R0 and R1

	If any exception occurs during the execution of the queued instructions, all output will be discarded

	If multiple exceptions would have theoretically occurred, which one is triggered is undefined
	If outputs from multiple instructions overlap, which one is written to the overlapping area is undefined
		If an exception would be generated by attempting to write one value there but not the other, the exception might not occur if the other value is what is written in the end
		This includes indirect writes via instructions such as `jmp` and `push`

	Current format ideas:
		A)
			effects:
				uses space efficiently when using many repetitions of the same opcodes
				allows reuse of immediate references
				easier for the CPU to parse

				requires all parameter lengths to be the same within the opcode
				wastes space when few repetitions of the same opcode exists and immediate references are rarely reused

			format:
				num_opcodes
				for each:
					opcode
					num_parameters
					for each:
						value
				size_of_immediate_references
				for each:
					value

		B) 
			effects:
				allows variable length parameters

				harder for the CPU to parse

			format:
				size_of_queue
				for each instruction:
					opcode
					parameters
					immediate references

		C)
			effects:
				allows variable length parameters
				allows reuse of immediate references

				harder for the CPU to parse
				larger if immediate references are not reused

			format:
				size_of_instructions
				for each instruction:
					opcode
					parameters
				size_of_immediate_references
				for each:
					value

	A minimum of <n> instructions must be accepted by all CPUs
		TODO: define n
		Specific implementations may accept more, up to the maximum specifiable by the format
